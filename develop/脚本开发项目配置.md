# 脚本开发项目配置

> **用途**: 定义HTML转JSON脚本的输入输出规范、文件路径、命名规则  
> **受众**: 脚本开发者（任何编程语言）  
> **配合文档**: JSON数据格式说明.md

---

## 1. 项目目录结构

### 1.1 完整目录树

```
output/                            # 输出目录（需创建）
    ├── json/                          # 单个JSON文件（中间产物）
    │   ├── e001.json
    │   ├── e028.json
    │   └── ...（150个文件）
    │
    ├── chunks/                        # Chunk文件（最终产物）
    │   ├── a3f5b2.json               # 包含5-10篇文章
    │   ├── d8e1c4.json
    │   └── ...（约15-20个文件）
    │
    └── manifest.json                  # 索引文件（最终产物）
```

### 1.2 路径说明

| 路径 | 说明 | 文件数量 |
|------|------|---------|
| `//////` | HTML源文件位置 | 150个 |
| `/output/json/` | 单个JSON输出（测试用） | 150个 |
| `/output/chunks/` | Chunk文件输出（部署用） | 15-20个 |
| `/output/manifest.json` | 索引文件 | 1个 |

---

## 2. 输入文件规范

### 2.1 HTML文件命名规则

**通用格式**:
```
[编号]. [难度] - [英文标题] [中文标题]【可选标记】.html
```

**实际示例**:
```
28. P1 - Triumph of the City 城市的胜利.html
56. P2 - The return of monkey life 猴群回归【高】.html
99. P3 - Voynich Manuscript 伏尼契手稿【高】.html
```

### 2.2 文件名组成部分

| 部分 | 格式 | 说明 | 是否必需 |
|------|------|------|---------|
| 编号 | 1-150的数字 | 可能不连续 | ✅ 必需 |
| 难度 | P1 / P2 / P3 | P1=简单, P2=中等, P3=困难 | ✅ 必需 |
| 英文标题 | 任意英文 | 文章标题 | ✅ 必需 |
| 中文标题 | 任意中文 | 翻译（空格分隔） | ❓ 可选 |
| 难度标记 | 【高】【中】【低】 | 可能缺失 | ❓ 可选 |

### 2.3 从文件名提取信息

**提取编号和难度的逻辑**:
1. 查找文件名开头的数字部分（可能是1位、2位或3位）
2. 查找紧跟的"P1"、"P2"或"P3"字符串
3. 提取编号作为整数，难度作为字符串

**示例**:
- `"28. P1 - Triumph..."` → 编号=28, 难度="P1"
- `"99. P3 - Voynich..."` → 编号=99, 难度="P3"
- `"5. P2 - Ancient..."` → 编号=5, 难度="P2"

**提取英文标题的逻辑**:
1. 在文件名中找到"P[123] - "之后的部分
2. 提取到第一个空格+非英文字符之前的内容
3. 如果提取失败，直接从HTML内容的`<h3>`标签提取更准确

### 2.4 识别所有HTML文件

**查找规则**:
1. 扫描目录: ``
2. 筛选条件: 文件扩展名为`.html` 且 文件名以数字开头
3. 排除: demo文件、测试文件等非题目文件
4. 排序: 按文件名中的编号排序

**预期结果**: 找到150个HTML文件

---

## 3. ID分配规则

### 3.1 ID格式定义

**格式**: 字母`e` + 3位数字补零

**范围**: `e001` 到 `e150`

### 3.2 ID分配策略

**规则**: 使用文件名中的编号直接映射

**映射关系**:

| 文件名编号 | 生成的ID | 说明 |
|-----------|---------|------|
| 1 | e001 | 补零到3位 |
| 5 | e005 | 补零到3位 |
| 28 | e028 | 补零到3位 |
| 56 | e056 | 补零到3位 |
| 99 | e099 | 补零到3位 |
| 150 | e150 | 三位数 |

**算法描述**:
```
1. 从文件名提取编号（如28）
2. 将编号转为3位字符串，不足3位前面补0
3. 在前面添加字母"e"
4. 结果: e028
```

### 3.3 特殊情况处理

**如果文件名编号超过150**:
- 报错并停止处理
- 原因: ID范围限制为e001-e150

**如果文件名编号重复**:
- 报错并列出重复的文件
- 要求人工处理后再运行

**如果文件名编号不连续**（如只有1,5,28,99）:
- 保留原编号，生成e001, e005, e028, e099
- 不强制连续，manifest中会正确记录

---

## 4. 输出文件命名规范

### 4.1 单个JSON文件命名

**输出路径**: `/Users/armazi/Desktop/code/ielts/output/json/`

**命名规则**: `[ID].json`

**示例**:
```
e001.json  ← 来自文件名编号1的HTML
e028.json  ← 来自文件名编号28的HTML
e056.json  ← 来自文件名编号56的HTML
e099.json  ← 来自文件名编号99的HTML
```

**用途说明**:
- 开发阶段: 便于单独测试和验证某篇文章
- 调试阶段: 可以快速定位问题文件
- 最终部署: 不部署此目录，仅作为中间产物

### 4.2 Chunk文件命名

**输出路径**: `/Users/armazi/Desktop/code/ielts/output/chunks/`

**命名规则**: `[6位hash].json`

**Hash格式**: 6位小写字母和数字组合（如`a3f5b2`）

**示例**:
```
a3f5b2.json  ← 包含8篇P1文章
d8e1c4.json  ← 包含8篇P1文章
b7k9m3.json  ← 包含8篇P2文章
z9x2v8.json  ← 包含10篇P3文章
```

---

## 5. Chunk分组规则

### 5.1 分组策略

**主要原则**: 按文章难度分组

**具体规则**:
1. 将所有150篇文章按difficulty字段分成三组
   - 第一组: difficulty=1 的所有P1文章
   - 第二组: difficulty=2 的所有P2文章
   - 第三组: difficulty=3 的所有P3文章

2. 每组内部再按文章ID顺序分批
   - 每批包含5-10篇文章
   - 推荐每批8篇（可调整）

3. 每批生成一个chunk文件

### 5.2 分组示例

**假设分布**: 50篇P1 + 50篇P2 + 50篇P3 = 150篇

**如果每个chunk包含8篇**:

```
P1文章组 (50篇):
  chunk-01: e001, e005, e008, e012, e015, e018, e022, e025  (8篇)
  chunk-02: e028, e031, e035, e038, e041, e044, e047, e050  (8篇)
  chunk-03: ... (8篇)
  ...
  chunk-07: ... (2篇) ← 最后一个chunk可能不满8篇

P2文章组 (50篇):
  chunk-08: ... (8篇)
  chunk-09: ... (8篇)
  ...

P3文章组 (50篇):
  chunk-15: ... (8篇)
  ...
```

**预期结果**: 约15-20个chunk文件

### 5.3 分组算法描述

**步骤1**: 分类
```
遍历所有文章JSON:
  如果 metadata.difficulty = 1:
    加入P1文章列表
  如果 metadata.difficulty = 2:
    加入P2文章列表
  如果 metadata.difficulty = 3:
    加入P3文章列表
```

**步骤2**: 分批
```
定义 每批大小 = 8

对于每个列表（P1/P2/P3）:
  当前批次 = 空列表
  
  遍历列表中的文章:
    将文章加入当前批次
    
    如果 当前批次大小 = 8:
      保存当前批次为一个chunk
      清空当前批次
  
  如果 当前批次不为空:
    保存剩余文章为最后一个chunk
```

### 5.4 批次大小调整

**可选大小**: 5-10篇

**调整依据**:
- 文件太大（每个chunk超过500KB）→ 减小到5-6篇
- 文件太小（每个chunk不到100KB）→ 增大到9-10篇
- 文章总数不能整除 → 最后一个chunk可能较小

**推荐**: 保持8篇/chunk，兼顾大小和数量

---

## 6. Hash生成规则

### 6.1 Hash用途

Hash作为chunk文件名，目的是:
1. **混淆**: 文件名不包含语义信息，提高安全性
2. **唯一**: 每个chunk有唯一标识
3. **简短**: 6位长度便于管理

### 6.2 Hash生成算法

**输入**: 两个参数组合
- 参数1: chunk的序号（从0开始计数）
- 参数2: chunk中第一篇文章的ID

**算法步骤**:
```
1. 创建输入字符串 = "chunk_" + 序号 + "_" + 第一篇文章ID
   示例: "chunk_0_e001"

2. 对输入字符串计算MD5哈希值
   示例: "a3f5b2c8d9e1f4..."（32位）

3. 取哈希值的前6位
   示例: "a3f5b2"

4. 确保是小写字母和数字
   示例: "a3f5b2" ✅
```

**示例**:
```
输入: chunk序号=0, 第一篇=e001
字符串: "chunk_0_e001"
MD5: "a3f5b2c8d9e1f4a7b6c5d4e3f2..."
取前6位: "a3f5b2"
结果文件名: a3f5b2.json

输入: chunk序号=1, 第一篇=e009
字符串: "chunk_1_e009"
MD5: "d8e1c4f7a8b9c6..."
取前6位: "d8e1c4"
结果文件名: d8e1c4.json
```

### 6.3 Hash冲突处理

**理论上**: 6位16进制hash有16^6 = 16,777,216种可能性

**实际使用**: 只需要15-20个hash

**冲突概率**: 极低（约0.0001%）

**如果发生冲突**:
1. 在输入字符串后添加递增数字: "chunk_0_e001_1"
2. 重新计算hash
3. 检查新hash是否冲突，直到找到唯一hash

---

## 7. Chunk文件结构

### 7.1 Chunk文件内容

**文件格式**: JSON

**顶层结构**:
```json
{
  "version": "1.0",
  "data": [
    文章1的完整JSON,
    文章2的完整JSON,
    ...
    文章N的完整JSON
  ]
}
```

**字段说明**:
- `version`: 字符串，格式版本号（固定为"1.0"）
- `data`: 数组，包含5-10篇文章的完整JSON对象

### 7.2 文章在Chunk中的位置

**Offset概念**: 文章在chunk的data数组中的索引位置（从0开始）

**示例**:
```json
{
  "version": "1.0",
  "data": [
    {"id": "e001", ...},  ← offset=0
    {"id": "e005", ...},  ← offset=1
    {"id": "e008", ...},  ← offset=2
    ...
  ]
}
```

**用途**: manifest.json中记录每篇文章的offset，便于快速定位

---

## 8. Manifest索引文件

### 8.1 Manifest作用

Manifest是整个题库的索引文件，功能:
1. 记录所有150篇文章的元数据
2. 记录每篇文章所在的chunk文件和位置
3. 提供搜索和筛选功能

### 8.2 Manifest完整结构

```json
{
  "version": "1.0.0",
  "totalExams": 150,
  "lastUpdated": "2025-10-16",
  "index": [
    {
      "id": "e001",
      "title": "Triumph of the City",
      "difficulty": 1,
      "questionCount": 13,
      "questionTypes": ["notes-completion", "true-false-ng"],
      "chunk": "a3f5b2",
      "offset": 0
    },
    {
      "id": "e028",
      "title": "Ancient Civilizations",
      "difficulty": 1,
      "questionCount": 13,
      "questionTypes": ["heading-matching", "summary-completion"],
      "chunk": "a3f5b2",
      "offset": 1
    }
    // ... 共150条
  ]
}
```

### 8.3 Manifest字段说明

**顶层字段**:

| 字段 | 类型 | 说明 |
|------|------|------|
| `version` | string | Manifest格式版本，固定"1.0.0" |
| `totalExams` | number | 文章总数，应等于150 |
| `lastUpdated` | string | 生成日期，格式"YYYY-MM-DD" |
| `index` | array | 文章索引数组 |

**index数组中每条记录的字段**:

| 字段 | 类型 | 说明 | 来源 |
|------|------|------|------|
| `id` | string | 文章ID | 文章JSON的id字段 |
| `title` | string | 英文标题 | 文章JSON的passage.title |
| `difficulty` | number | 难度级别（1/2/3） | 文章JSON的metadata.difficulty |
| `questionCount` | number | 题目数量 | 文章JSON的metadata.totalQuestions |
| `questionTypes` | array | 题型列表 | 文章JSON的metadata.questionTypes |
| `chunk` | string | 所在chunk的hash文件名 | 分组时确定 |
| `offset` | number | 在chunk.data数组中的位置 | 分组时确定 |

### 8.4 Manifest生成逻辑

**步骤描述**:

1. 初始化manifest对象，设置version, totalExams, lastUpdated

2. 遍历所有生成的chunk文件:
   - 记录当前chunk的hash文件名
   - 读取chunk中的data数组
   
3. 对于data数组中的每篇文章:
   - 记录其在数组中的位置（offset）
   - 提取文章的id, title, difficulty等字段
   - 创建一条索引记录，包含:
     * 文章的元数据（id, title, difficulty等）
     * 所在chunk的文件名（hash）
     * 在chunk中的位置（offset）
   - 将索引记录添加到manifest.index数组

4. 按文章ID排序manifest.index数组

5. 保存为manifest.json文件

### 8.5 使用Manifest查找文章

**查找流程**:
```
1. 用户请求文章ID: "e028"

2. 在manifest.json中查找id="e028"的记录:
   {
     "id": "e028",
     "chunk": "a3f5b2",
     "offset": 1,
     ...
   }

3. 读取chunk文件: chunks/a3f5b2.json

4. 提取data数组的第1个元素（offset=1）

5. 得到完整的文章JSON
```

---

## 9. 测试流程

### 9.1 测试文件选择

**第一阶段测试**: 使用3个示例文件

**选择原因**:
1. 这3个文件已有手工制作的JSON样例可供对比
2. 覆盖P1/P2/P3三个难度级别
3. 包含的题型较全面

**测试文件列表**:
```
28. P1 - Triumph of the City 城市的胜利.html
56. P2 - The return of monkey life 猴群回归【高】.html
99. P3 - Voynich Manuscript 伏尼契手稿【高】.html
```

**预期输出**:
```
output/json/e028.json
output/json/e056.json
output/json/e099.json
```

### 9.2 测试步骤

**步骤1: 单文件转换**
- 选择一个测试文件（如28号）
- 运行转换脚本
- 检查是否成功生成e028.json
- 检查JSON格式是否正确

**步骤2: 内容验证**
- 对比生成的JSON与demo/sample-chunk-a3f5b2.json中的对应文章
- 检查字段是否完整
- 检查答案格式是否正确（小写、数组等）

**步骤3: 批量测试**
- 转换全部3个测试文件
- 检查是否都能成功生成
- 统计错误和警告

**步骤4: 完整验证**
- 运行所有验证规则（见下一节）
- 确认100%通过

### 9.3 验证清单

对每个生成的JSON文件，必须检查以下项目:

**基础结构验证**:
- [ ] 文件是否为有效的JSON格式
- [ ] 是否包含所有必需的顶层字段（id, passage, questions, metadata）
- [ ] 字段类型是否正确

**ID和元数据验证**:
- [ ] id格式正确（e开头+3位数字）
- [ ] metadata.difficulty 是 1、2 或 3
- [ ] metadata.totalQuestions 等于 questions数组长度
- [ ] metadata.questionTypes 数组不为空

**文章内容验证**:
- [ ] passage.title 不为空
- [ ] passage.paragraphs 至少有1个段落
- [ ] 每个段落的label是字符串或null（不能是空字符串）
- [ ] 每个段落的content不为空

**题目验证**:
- [ ] questionNumber从1开始连续递增
- [ ] 根据difficulty，questionNumber范围正确:
  - P1: 1-13 或 1-14
  - P2: 14-26 或 14-27
  - P3: 27-40
- [ ] 每道题的type是有效的题型代码
- [ ] 每道题的instruction不为空
- [ ] 每道题的content根据题型包含必需字段

**答案格式验证**（重要）:
- [ ] 所有答案键都是小写（如果有的话）
- [ ] 字符串答案都是小写（除了TRUE/FALSE/NOT GIVEN和选项字母A-G）
- [ ] 多选题的答案是数组格式，不是字符串
- [ ] 答案字符串已去除首尾空格

**特殊题型验证**:
- [ ] 拖拽题（paragraph-matching等）包含canReuse字段
- [ ] 填空题包含wordLimit字段
- [ ] 多选题包含checkboxGroupName和occupiesQuestions字段

### 9.4 错误记录

**如果验证失败**:
1. 记录错误的文件ID
2. 记录具体错误类型
3. 记录错误位置（如第几道题）
4. 继续验证其他文件
5. 生成错误报告

**错误报告格式**:
```json
{
  "totalFiles": 3,
  "passedFiles": 2,
  "failedFiles": 1,
  "errors": [
    {
      "fileId": "e028",
      "errorType": "答案格式错误",
      "location": "question 5",
      "details": "答案应为小写: 'Disease' -> 'disease'"
    }
  ]
}
```

---

## 10. 批量处理流程

### 10.1 处理顺序

**推荐顺序**:

**第一步: 单文件测试**
- 处理1个文件（如e028）
- 验证通过后继续

**第二步: 小批量测试**
- 处理3个示例文件（e028, e056, e099）
- 验证通过后继续

**第三步: 难度分组测试**
- 先处理所有P1文章（约50篇）
- 验证通过后处理P2
- 最后处理P3

**第四步: 完整处理**
- 处理全部150个文件
- 生成所有单个JSON

**第五步: 生成Chunk**
- 按难度分组
- 生成15-20个chunk文件

**第六步: 生成Manifest**
- 汇总所有chunk信息
- 生成manifest.json

### 10.2 处理策略

**并行处理** (如果可能):
- HTML转JSON是独立操作，可并行处理
- 建议每次处理10-20个文件
- 避免一次性加载150个文件到内存

**错误处理**:
- 单个文件失败不应影响其他文件
- 记录失败的文件ID和原因
- 成功的文件正常输出
- 最后汇总错误报告

**进度显示**:
- 显示当前处理到第几个文件
- 显示百分比进度
- 估算剩余时间

### 10.3 输出文件清单

**脚本运行完成后应生成**:

```
output/
├── json/                      # 150个单个JSON文件
│   ├── e001.json
│   ├── e002.json
│   ├── ...
│   └── e150.json
│
├── chunks/                    # 15-20个chunk文件
│   ├── a3f5b2.json
│   ├── d8e1c4.json
│   ├── ...
│   └── z9x2v8.json
│
├── manifest.json              # 索引文件
│
└── reports/                   # 报告目录
    ├── success.json          # 成功处理的文件列表
    ├── errors.json           # 错误报告
    └── statistics.json       # 统计信息
```

---

## 11. 文件大小估算

### 11.1 单个JSON文件

**估算**:
- 每篇文章: 15-30KB（含文章内容和题目）
- 150篇总计: 约2-4MB

### 11.2 Chunk文件

**估算**:
- 每个chunk（8篇）: 120-240KB
- 15-20个chunk总计: 约2-4MB

### 11.3 Manifest文件

**估算**:
- 每条记录约200字节
- 150条: 约30KB

### 11.4 总存储空间

**output目录总大小**: 约5-10MB

---

## 12. 常见问题

### Q1: 如果HTML文件中的编号不是1-150连续怎么办？

**答**: 
- 保留原文件名编号
- ID仍然使用原编号生成（如文件名28 → e028）
- 可能出现e001, e005, e028这样的跳号
- manifest.json会正确记录所有实际存在的文章
- totalExams字段记录实际文章数量（可能不是150）

### Q2: 如果某个HTML文件解析失败怎么办？

**答**:
- 记录错误到errors.json
- 继续处理其他文件
- 不生成该文件对应的JSON
- 在manifest中也不包含该文章
- 最后提示用户检查失败的文件

### Q3: 如何决定chunk的大小（5篇还是10篇）？

**答**:
- 默认使用8篇每chunk
- 可以根据实际情况调整:
  * 如果chunk文件超过500KB，减少到5-6篇
  * 如果chunk文件小于100KB，增加到9-10篇
- 同一难度的所有chunk应使用相同大小

### Q4: Hash冲突的概率有多大？

**答**:
- MD5取前6位有16^6 = 16,777,216种可能
- 我们只需要15-20个hash
- 冲突概率约为 0.0001%
- 几乎不可能发生
- 即使发生，也有冲突处理机制

### Q5: 是否需要对chunk文件进行进一步压缩或混淆？

**答**:
- 当前版本: 仅使用hash文件名混淆
- 文件内容保持JSON格式便于调试
- 后续可选: 
  * 压缩JSON（去除空格）
  * Base64编码
  * 字段名混淆（title→t, questions→q）
- 这些优化不在当前脚本范围内

---

## 13. 脚本接口建议

### 13.1 推荐的命令行参数

虽然不限定具体编程语言，但建议脚本提供以下功能:

**模式选择**:
- 测试模式: 只处理3个示例文件
- 单文件模式: 处理指定的一个HTML文件
- 批量模式: 处理所有150个文件

**输出控制**:
- 是否生成单个JSON文件
- 是否生成chunk文件
- 是否生成manifest
- 输出目录位置

**验证选项**:
- 是否进行验证
- 验证失败是否停止
- 是否生成详细报告

### 13.2 建议的工作流

**开发阶段**:
```
1. 运行测试模式 → 生成3个JSON
2. 手动检查生成结果
3. 修复问题
4. 重复直到通过
```

**生产运行**:
```
1. 运行批量模式 → 生成所有JSON
2. 自动验证
3. 生成chunk文件
4. 生成manifest
5. 输出统计报告
```

---

## 14. 交付清单

### 14.1 必须交付的文件

- [ ] 转换脚本（任何语言）
- [ ] 验证脚本（可选，可集成在转换脚本中）
- [ ] README.md（脚本使用说明）
- [ ] output/json/ 目录（150个JSON文件）
- [ ] output/chunks/ 目录（15-20个chunk文件）
- [ ] output/manifest.json（索引文件）

### 14.2 建议交付的文件

- [ ] output/reports/errors.json（错误报告，如有）
- [ ] output/reports/statistics.json（统计信息）
- [ ] 依赖说明文件（如requirements.txt、package.json等）
- [ ] 测试报告或验证结果

---

## 15. 相关文档

**核心文档**:
- **JSON数据格式说明.md** - JSON结构详细定义（必读）
- **PDF转网页工作流.md** - HTML源文件生成规则和题型定义

**参考文档**:
- **JSON与HTML工作流对应指南.md** - HTML元素到JSON字段的映射关系
- **预制JSON题库方案.md** - 整体架构和设计方案

